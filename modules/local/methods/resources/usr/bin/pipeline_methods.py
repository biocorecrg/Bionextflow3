#!/usr/bin/env python

import yaml 
import argparse
import re


parser = argparse.ArgumentParser(description="Retrieve information from meta.yml of each module for methods description.", epilog="Example usage: python methods.py -m methods_output.yml -n 'params'")
parser.add_argument("-d","--methods_data", help="Path to the methods data yml file", required=True)
parser.add_argument("-m", "--methods", help="Path to the methods.yaml file generated by make_yaml_methods function ", required=True)
parser.add_argument("-t", "--template", help="Path to the template.yml with the description of the methods", required=True)
args = parser.parse_args()


##### Reading the yaml files #####

with open (args.methods_data, 'r') as file:
    methods_data = yaml.safe_load(file)

with open (args.methods, 'r') as file:
    mymethods = yaml.safe_load(file)

with open (args.template, 'r') as file:
    template_rows = yaml.safe_load(file)

all_tools_info  = methods_data['tools']
workflow        = methods_data['workflow']
pipeline_name   = list(workflow.keys())[1]

parameters_info = mymethods['progPars']
reporting_info  = mymethods['reporting']

citations_info  = {}
versions_info   = {}
for tool in all_tools_info.keys():
  versions_info[tool] =  all_tools_info[tool]["version"]
  if ( "citation" in all_tools_info[tool]):
    citations_info[tool] = all_tools_info[tool]["citation"]
  else:
    citations_info[tool] = all_tools_info[tool]["homepage"]

info_4_template = versions_info | reporting_info

for tool_name in parameters_info.keys():
    extrapars = parameters_info[tool_name]
    if(extrapars != ""):
        if (tool_name in info_4_template):
          info_4_template[tool_name] = str(info_4_template[tool_name]) +  " with parameters " + extrapars



##### text to be save as methods_description_mqc.yml that will be used by multiqc to generate the methods section in the report #####


def replace_citations(text):
    counter = 0
    def repl(match):
        nonlocal counter
        counter += 1
        return f"[{counter}]"
    return re.sub(r"#\[CIT\]", repl, text)

methods_description=f"""
id: "methods-description"
description: ""
section_name: "Methods Description"
plot_type: "html"

data: |
"""

for section_name in template_rows.keys():
    if (section_name == "header"):
      my_row  = template_rows[section_name]
      for key, value in sorted(info_4_template.items(), key=lambda x: len(x[0]), reverse=True):  
          my_row = my_row.replace(f"#{key}", str(value))
      methods_description += "\n " + my_row

    elif (section_name in info_4_template):
      my_row  = template_rows[section_name]
      my_info = info_4_template[section_name]

      # sanitize in case of boolean
      if (str(my_info).upper() == "NO"):
        my_info = ""

      # check BOOL
      if(my_row.startswith('(BOOL)') and my_info == "" ):
        print("skipping line " + my_row )
      else:
       # Replace placeholders       
        for key, value in sorted(info_4_template.items(), key=lambda x: len(x[0]), reverse=True):
          my_row = my_row.replace(f"#{key}", str(value))
          
        methods_description += "\n " + my_row
    
    elif(section_name == "tail"):
      my_row  = template_rows[section_name]
      for key, value in citations_info.items():
        my_row = my_row.replace(f"#{key}", str(value))
        
      #sanitize removing citations not needed
      clean_rows = [line for line in my_row.splitlines() if '#' not in line]
      my_row = "\n  ".join(clean_rows)
      methods_description += "\n " + my_row 

#replace citation placeholders with numbers
methods_description = replace_citations(methods_description)


with open('methods_description_mqc.yml','w') as file:
    file.write(methods_description)

